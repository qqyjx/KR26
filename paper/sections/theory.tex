% ===== ยง4  Theoretical Analysis =====
\section{Theoretical Properties}\label{sec:theory}

We establish three groups of results for the \textsc{Argus} repair operator: compliance with adapted AGM postulates, computational complexity under the principal argumentation semantics, and soundness of the ASP encoding.

\subsection{AGM Compliance}

The AGM theory of belief revision~\cite{alchourron1985agm} prescribes rationality postulates that any principled revision operator should satisfy.  We adapt three core postulates---success, inclusion, and vacuity---to the argumentation repair setting.  Intuitively, success requires that the repair achieves the desired outcome; inclusion requires that the repaired framework retains as much of the original as possible; and vacuity requires that no edits are made when the current state already satisfies the goal.

\begin{theorem}[Adapted AGM Compliance]\label{thm:agm}
Let $\mathit{AF}=(\mathcal{A},\mathcal{R})$ be an argumentation framework, $\sigma$ an argumentation semantics, $a_t$ a target argument, $s\in\{\textsc{in},\textsc{out}\}$ a desired status, $\Delta$ an evidence update, and $\kappa$ a strictly positive cost function ($\kappa(o)>0$ for every operation~$o$).  If a valid repair exists, then every optimal repair $\mathit{Ops}^*$ returned by Definition~\ref{def:repair} satisfies:
\begin{enumerate}
    \item \textbf{Success.} The target $a_t$ has status $s$ in $\mathit{AF}'=\mathsf{apply}(\mathit{AF},\Delta,\mathit{Ops}^*)$ under $\sigma$.
    \item \textbf{Inclusion.} $\mathcal{A}\cap\mathcal{A}' \supseteq \mathcal{A}\setminus\{a\mid \mathsf{del\_arg}(a)\in\mathit{Ops}^*\}$ and $\mathcal{R}\cap\mathcal{R}' \supseteq \mathcal{R}\setminus\{(a,b)\mid \mathsf{del\_att}(a,b)\in\mathit{Ops}^*\}$.
    \item \textbf{Vacuity.} If $a_t$ already has status $s$ in $\mathsf{apply}(\mathit{AF},\Delta,\emptyset)$ under $\sigma$, then $\mathit{Ops}^*=\emptyset$ and $\mathit{cost}(\mathit{Ops}^*)=0$.
\end{enumerate}
\end{theorem}

\begin{proof}[Proof sketch]
Success follows directly from the validity constraint in Definition~\ref{def:repair}: any repair returned by the solver satisfies the prescribed status.  Inclusion holds because elements not targeted by any deletion operation are preserved by the semantics of $\mathsf{apply}$; moreover, optimality ensures that every deletion in $\mathit{Ops}^*$ is necessary---removing an unnecessary $\mathsf{del\_arg}(a)$ would yield a valid repair of strictly lower cost ($\kappa>0$), contradicting optimality.  Vacuity is immediate: when no edits are needed, the empty set is valid and has cost zero, so no non-empty set can be cheaper.
\end{proof}

\begin{example}[Continuing Example~\ref{ex:running}]\label{ex:agm}
Vacuity: in~$F_0$, where $a_3$ already defeats~$a_0$ and keeps~$a_4$ accepted, $\mathit{Ops}^* = \emptyset$ and the repair cost is zero.
Success: after incorporating $\Delta = (\{a_5\}, \{(a_5, a_3)\}, \emptyset, \emptyset)$, $a_0$ reinstates and rejects~$a_4$; the repair $\{\mathsf{add\_arg}(a_6), \mathsf{add\_att}(a_6, a_5)\}$ restores~$a_4$ to accepted status by defeating~$a_5$, which in turn restores~$a_3$ and re-defeats~$a_0$.
Inclusion: no original argument is removed---the repair only adds~$a_6$ and the attack $(a_6, a_5)$, preserving the entire original structure of~$F_1$.
\end{example}

Among the eight classical AGM postulates~\cite{katsuno1992update}, \emph{consistency} and \emph{extensionality} also hold: consistency follows because every valid repair produces a framework with at least one $\sigma$-extension (under preferred semantics), and extensionality holds because the operator is defined purely over graph structure.
\emph{Recovery} fails in our setting.  In Example~\ref{ex:running}, repairing $F_1$ yields $F_2$ by adding $a_6$ and $(a_6,a_5)$; if the evidence $a_5$ were subsequently retracted, $F_2$ would retain $a_6$ and its attack---the original framework $F_0$ is not recovered.  This asymmetry is fundamental: structural additions made during repair cannot be automatically unwound by evidence retraction, unlike classical belief revision where recovery ensures reversibility.
\emph{Closure}, \emph{superexpansion}, and \emph{subexpansion} presuppose deductively closed belief sets---constructs without natural analogues in argumentation frameworks where ``beliefs'' are graph-structural elements rather than logical sentences.
To the best of our knowledge, this is the first formal bridge between AGM rationality criteria and argumentation-based explanation repair for LLM self-explanations.  The contribution lies in identifying which AGM postulates have meaningful argumentation analogues and showing that they \emph{characterize} the class of minimum-cost repair operators:

\begin{theorem}[Representation]\label{thm:representation}
A repair operator~$\circ$ satisfies adapted success, inclusion, and vacuity for every AF, semantics~$\sigma$, target~$a_t$, and evidence update~$\Delta$ if and only if there exists a strictly positive cost function~$\kappa$ such that~$\circ$ returns a minimum-cost valid repair under~$\kappa$.
\end{theorem}

\begin{proof}[Proof sketch]
($\Rightarrow$) Theorem~\ref{thm:agm} establishes that every minimum-cost repair under positive~$\kappa$ satisfies all three postulates.
($\Leftarrow$) Given an operator satisfying the three postulates, define~$\kappa(o) = 1$ for every operation~$o$.  Success guarantees validity; vacuity ensures the empty set is returned when no repair is needed, so any non-empty output incurs positive cost; inclusion ensures every operation in the output is necessary, since removing any one would either violate success or produce a valid repair of strictly lower cost---contradicting the assumption that the operator already returns a repair satisfying inclusion.  Hence the output is a minimum-cost valid repair under unit cost.  The full construction for general~$\kappa$ appears in Appendix~\ref{app:representation}.
\end{proof}

\subsection{Computational Complexity}

The complexity of the repair problem depends critically on the choice of argumentation semantics.  Since the repair problem reduces to enforcement after incorporating~$\Delta$, it inherits the complexity landscape of extension enforcement~\cite{dunne2009complexity,dvorak2018computational}; the additional overhead of processing~$\Delta$ and evaluating heterogeneous cost functions is polynomial and does not alter the complexity class.  Our results assume credulous acceptance (as defined in \S\ref{sec:preliminaries}).

\begin{theorem}[Repair Complexity]\label{thm:complexity}
The decision version of the minimal-change repair problem---``does there exist a valid repair of cost at most $C$?''---has the following complexity under credulous acceptance:
\begin{enumerate}
    \item Under grounded semantics, the problem is in \textbf{P}.
    \item Under preferred and stable semantics, the problem is \textbf{NP}-complete.
\end{enumerate}
Under skeptical acceptance with stable semantics, the problem rises to $\mathbf{\Sigma_2^P}$-completeness.
\end{theorem}

\begin{proof}[Proof sketch]
For grounded semantics, the unique grounded extension is computable in polynomial time via the characteristic function~\cite{dung1995acceptability}.  Membership in P follows by reduction to grounded enforcement, which Dvo\v{r}\'ak and Dunne~\cite{dvorak2018computational} showed is solvable in polynomial time by exploiting the monotonicity of the characteristic function.  Our repair problem reduces to enforcement: we first incorporate the evidence update~$\Delta$ into the framework and then seek a minimum-cost set of edit operations that enforces the target argument's desired acceptability status; since both the incorporation of~$\Delta$ and the verification of any candidate repair via the grounded extension are polynomial, the overall decision problem is in~P.
For preferred semantics, hardness reduces from NP-hard extension enforcement~\cite{baumann2010complexity}; membership in NP follows since a valid repair paired with a witnessing admissible set containing~$a_t$ can be guessed and verified in polynomial time.
For stable semantics under credulous acceptance, membership in NP follows by the same certificate argument: a repair paired with a witnessing stable extension is verifiable in polynomial time.
Under skeptical acceptance, verifying that \emph{every} stable extension accepts the target is co-NP-hard~\cite{dvorak2018computational}, yielding $\Sigma_2^P$-completeness.
Full reductions follow standard techniques from the enforcement literature~\cite{baumann2010complexity,wallner2017complexity}.
\end{proof}

Note that the reduction to enforcement establishes complexity bounds but does not subsume the repair problem, which additionally involves evidence updates~$\Delta$, heterogeneous cost functions, and NLI-grounded candidate generation (\S\ref{sec:relation}).  These results motivate the $k$-neighborhood approximation (\S\ref{sec:repair}), ensuring tractability under preferred semantics for practical framework sizes.

\subsection{Soundness of the ASP Encoding}

\begin{proposition}[Encoding Correctness]\label{prop:encoding}
The ASP encoding described in \S\ref{sec:repair}, when applied to the full framework without $k$-neighborhood restriction, is sound and complete with respect to optimal repairs under grounded and preferred semantics.  That is, every optimal answer set of the program corresponds to a valid minimum-cost repair, and every valid minimum-cost repair has a corresponding optimal answer set.
\end{proposition}

The proof follows from the established correctness of the argumentation encodings of Egly et al.~\cite{egly2010asparg} composed with the standard semantics of weak constraints in ASP solvers such as \emph{clingo}~\cite{gebser2019clingo}.  The composition is sound because the generate rules enumerate exactly the feasible edit operations and the integrity constraints enforce the semantics of the repaired framework, while the optimization directive selects minimum-cost solutions.
We next evaluate whether these theoretical properties hold in practice and measure the empirical gains of the \textsc{Argus} repair operator.
